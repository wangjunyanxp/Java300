引用类型（强、弱、软、虚） 【面试题】

    强引用        StrongReference        引用指向对象，gc运行时不回收
    软引用        SoftReference        引用指向对象，gc运行时可能回收（JVM内存不够时）
    弱引用        WeakReference        引用指向对象，gc运行时立即回收
    虚引用        PhantomReference        类似于无引用，主要跟踪对象被回收的状态，不能单独使用，必须与引用队列 ReferenceQueue 联合使用（Phantom幽灵）

    目的：避免对象长期驻留在内存中，解决GC回收时机问题

强引用
    比如创建的字符串常量，即使不用了，因为可能会被其他共享，所以不被GC

软引用
    常被用于做缓存


WeakHashMap：
    以弱键 实现的基于哈希表的 Map。
    在 WeakHashMap 中，当某个键不再正常使用时，将自动移除其条目。
    更精确地说，对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的丢弃，这就使该键成为可终止的，被终止，然后被回收。
    丢弃某个键时，其条目从映射中有效地移除，因此，该类的行为与其他的 Map 实现有所不同。

IdentityHashMap
    当且仅当 (k1==k2) 时，才认为两个键 k1 和 k2 相等
    此类利用哈希表实现 Map 接口，比较键（和值）时使用引用相等性代替对象相等性。
    换句话说，在 IdentityHashMap 中，当且仅当 (k1==k2) 时，才认为两个键 k1 和 k2 相等
    （在正常 Map 实现（如 HashMap）中，当且仅当满足下列条件时才认为两个键 k1 和 k2 相等：(k1==null ? k2==null : e1.equals(e2))）。

    注意：键是常量池中的字符串的时候，指向它的Key，其实都是指向内存中常量池里的同一个字符串。

    补充：
    此类不是 通用 Map 实现！此类实现 Map 接口时，它有意违反 Map 的常规协定，该协定在比较对象时强制使用 equals 方法。此类设计仅用于其中需要引用相等性语义的罕见情况。
    此类的典型用法是拓扑保留对象图形转换，如序列化或深层复制。要执行这样的转换，程序必须维护用于跟踪所有已处理对象引用的“节点表”。节点表一定不等于不同对象，即使它们偶然相等也如此。此类的另一种典型用法是维护代理对象。例如，调试设施可能希望为正在调试程序中的每个对象维护代理对象。


EnumMap
    与枚举类型键一起使用的专用 Map 实现。枚举映射中所有键都必须来自单个枚举类型，该枚举类型在创建映射时显式或隐式地指定。枚举映射在内部表示为数组。此表示形式非常紧凑且高效。
    枚举映射根据其键的自然顺序 来维护（该顺序是声明枚举常量的顺序）。在 collection 视图（keySet()、entrySet() 和 values()）所返回的迭代器中反映了这一点。
    构造器：
        EnumMap(Class<K> keyType)
        创建一个具有指定键类型的空枚举映射。
